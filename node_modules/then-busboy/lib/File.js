"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _fs = require("fs");

var _path = require("path");

var _stream = _interopRequireDefault(require("stream"));

var _invariant = _interopRequireDefault(require("@octetstream/invariant"));

var _isPlainObject = _interopRequireDefault(require("./util/isPlainObject"));

var _isString = _interopRequireDefault(require("./util/isString"));

var _getType = _interopRequireDefault(require("./util/getType"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class File {
  /**
   * File class.
   *
   * @param {object} options
   *
   * @constructor
   *
   * @api private
   */
  constructor(options) {
    _defineProperty(this, "read", () => new Promise((resolve, reject) => {
      const data = [];

      const onReadable = () => {
        const ch = this.contents.read();

        if (ch != null) {
          data.push(ch);
        }
      };

      const onEnd = () => resolve(Buffer.concat(data));

      this.contents.on("error", reject).on("readable", onReadable).on("end", onEnd);
    }));

    _defineProperty(this, "write", path => new Promise((resolve, reject) => {
      if (!path || !(0, _isString.default)(path)) {
        path = this.path;
      } // Prevent writing file to its source


      if (this.contents.path === path) {
        return resolve();
      }

      this.contents.on("error", reject).on("end", resolve).pipe((0, _fs.createWriteStream)(path));
    }));

    (0, _invariant.default)(!(0, _isPlainObject.default)(options), TypeError, "File options should be a plain object. Received", (0, _getType.default)(options));
    const {
      contents,
      filename,
      enc,
      mime
    } = options;
    (0, _invariant.default)(!contents, "File contents required.");
    (0, _invariant.default)(!(contents instanceof _stream.default), TypeError, "Contents should be a Stream. Received %s", (0, _getType.default)(contents));
    (0, _invariant.default)(!filename, "Filename required.");
    (0, _invariant.default)(!(0, _isString.default)(filename), TypeError, "Filename should be a string. Received %s", (0, _getType.default)(filename));
    (0, _invariant.default)(!enc, "File encoding required.");
    (0, _invariant.default)(!(0, _isString.default)(enc), TypeError, "File encoding should be a string. Received %s", (0, _getType.default)(enc));
    (0, _invariant.default)(!mime, "File mime type required.");
    (0, _invariant.default)(!(0, _isString.default)(mime), TypeError, "File mime type should be a string. Received %s", (0, _getType.default)(mime));
    const ext = (0, _path.extname)(filename);
    const base = (0, _path.basename)(filename, ext);
    this.__contents = contents;
    this.__stream = contents;
    this.__filename = (0, _path.basename)(filename);
    this.__basename = base;
    this.__extname = ext;
    this.__mime = mime;
    this.__enc = enc; // this.__path = join(tmpdir(), `${nanoid()}_${this.filename}`)

    this.__path = filename;
    this.toJSON = this.toJSON.bind(this);
    this.inspect = this.inspect.bind(this);
  }

  get contents() {
    return this.__contents;
  }

  get stream() {
    return this.__stream;
  }

  get filename() {
    return this.__filename;
  }

  get basename() {
    return this.__basename;
  }

  get extname() {
    return this.__extname;
  }

  get enc() {
    return this.__enc;
  }

  get mime() {
    return this.__mime;
  }

  get path() {
    return this.__path;
  }
  /**
   * Read file contents from a stream
   *
   * @return {Promise<Buffer>}
   */


  toJSON() {
    return this.inspect();
  }

  toString() {
    return this.inspect();
  }

  inspect() {
    return `<File: ${this.filename}>`;
  }

}

var _default = File;
exports.default = _default;